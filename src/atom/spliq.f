c
c Copyright (c) 1998-2004 The OPIUM Group
c
c This program is free software; you can redistribute it and/or modify
c it under the terms of the GNU General Public License as published by
c the Free Software Foundation; either version 2 of the License, or
c (at your option) any later version.
c
c This program is distributed in the hope that it will be useful,
c but WITHOUT ANY WARRANTY; without even the implied warranty of
c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
c GNU General Public License for more details.
c
c You should have received a copy of the GNU General Public License
c along with this program; if not, write to the Free Software
c Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
c
c
      subroutine spliq(x,y,yp,ypp,n,xlo,xup,nup,ans,ierr)
      implicit double precision(a-h,o-z)
      dimension x(n),y(n),yp(n),ypp(n),xup(nup),ans(nup)
c
c
c     Revision 1.1  89/10/26  19:53:49  sverre
c     Initial revision
c     
c     sandia mathematical program library
c     applied mathematics division 2613
c     sandia laboratories
c     albuquerque, new mexico  87185
c     control data 6600/7600  version 7.2  may 1978
c  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                    issued by sandia laboratories                     *
c  *                   a prime contractor to the                       *
c  *                united states department of energy                 *
c  * * * * * * * * * * * * * * * notice  * * * * * * * * * * * * * * * *
c  * this report was prepared as an account of work sponsored by the   *
c  * united states government.  neither the united states nor the      *
c  * united states department of energy nor any of their employees,    *
c  * nor any of their contractors, subcontractors, or their employees  *
c  * makes any warranty, express or implied, or assumes any legal      *
c  * liability or responsibility for the accuracy, completeness or     *
c  * usefulness of any information, apparatus, product or process      *
c  * disclosed, or represents that its use would not infringe          *
c  * owned rights.                                                     *
c  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c  * the primary document for the library of which this routine is     *
c  * part is sand77-1441.                                              *
c  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     this routine was written by m. k. gordon
c
c     abstract
c
c     subroutine spliq integrates a cubic spline (generated by
c     splift, smoo, etc.) on the intervals (xlo,xup(i)), where xup
c     is a sequence of upper limits on the intervals of integration.
c     the only restrictions on xlo and xup(*) are
c                xlo .lt. xup(1),
c                xup(i) .le. xup(i+1)   for each i .
c     endpoints beyond the span of abscissas are allowed.
c     the spline over the interval (x(i),x(i+1)) is regarded
c     as a cubic polynomial expanded about x(i) and is integrated
c     analytically.
c
c     description of arguments
c         the user must dimension all arrays appearing in the call list,
c         e.g.  x(n), y(n), yp(n), ypp(n), xup(nup), ans(nup)
c
c      --input--
c
c        nout - unit for error messages
c        x    - array of abscissas (in increasing order) that define the
c               spline.  usually x is the same as x in splift or smoo.
c        y    - array of ordinates that define the spline.  usually y is
c               the same as y in splift or as r in smoo.
c        yp   - array of first derivatives of the spline at abscissas.
c               usually yp is the same as yp in splift or r1 in smoo.
c        ypp  - array of second derivatives that define the spline.
c               usually ypp is the same as ypp in splift or r2 in smoo.
c        n    - the number of data points that define the spline.
c        xlo  - left endpoint of integration intervals.
c        xup  - right endpoint or array of right endpoints of
c               integration intervals in ascending order.
c        nup  - the number of right endpoints.  if nup is greater than
c               1, then xup and ans must be dimensioned at least nup.
c
c      --output--
c
c        ans -- array of integral values, that is,
c               ans(i) = integral from xlo to xup(i)
c        ierr -- error status
c                = 1 integration successful
c                = 2 improper input - n.lt.4 or nup.lt.1
c                = 3 improper input - abscissas not in
c                        strictly ascending order
c                = 4 improper input - right endpoints xup not
c                        in ascending order
c                = 5 improper input - xlo.gt.xup(1)
c                = 6 integration successful but at least one endpoint
c                        not within span of abscissas
c
c   check for improper input
c
c
      nout=6
      ierr = 2
      if(n .ge. 4  .and.  nup .ge. 1) go to 1
      write(nout,110)
 110  format(' in spliq, either n.lt.4 or nup.lt.1')
      return
 1    nm1 = n-1
      nm2 = n-2
      ierr = 3
      do 2 i = 1,nm1
        if(x(i) .lt. x(i+1)) go to 2
        write(nout,120)
 120    format(' in spliq, abscissas not in ascending order')
        return
 2      continue
      if(nup .eq. 1) go to 4
      ierr = 4
      do 3 i = 2,nup
        if(xup(i-1) .le. xup(i)) go to 3
        write(nout,130)
 130    format(' in spliq, right endpoints not in ascending order')
        return
 3      continue
 4    ierr = 5
      if(xlo .le. xup(1)) go to 5
      write(nout,140)
 140  format(' in spliq, xlo .gt. xup(1)')
      return
    5 ierr = 1
      if(xlo .lt. x(1)  .or.  xup(nup) .gt. x(n)) ierr = 6
c
c   locate xlo in interval (x(i),x(i+1))
c
      do 10 i = 1,nm2
        if(xlo .lt. x(i+1)) go to 20
 10     continue
      i = nm1
 20   hlo = xlo-x(i)
      hlo2 = hlo*hlo
      hi = x(i+1)-x(i)
      hi2 = hi*hi
      do 30 j = 1,nup
        if(xup(j) .gt. x(i+1)  .and.  xlo .lt. x(nm1)) go to 40
c
c   compute special cases of xup in interval with xlo
c
        hup = xup(j)-x(i)
        hsum = hup+hlo
        hdiff = hup-hlo
        hup2 = hup*hup
        sum = (ypp(i+1)-ypp(i))*hsum*hdiff*(hup2+hlo2)/(24.D0*hi)
        sum = sum + ypp(i)*hdiff*(hup2+hlo*hup+hlo2)/6.D0
        sum = sum + yp(i)*hdiff*hsum/2.D0
        sum = sum + y(i)*hdiff
 30     ans(j) = sum
      return
c
c   compute integral between xlo and x(i+1) as four terms in taylor
c   polynomial and advance i to i+1
c
 40   hdiff = hi-hlo
      hsum = hi+hlo
      sum0 = y(i)*hdiff
      sum1 = yp(i)*hdiff*hsum
      sum2 = ypp(i)*hdiff*(hi2+hi*hlo+hlo2)
      sum3 = (ypp(i+1)-ypp(i))*hdiff*hsum*(hi2+hlo2)/hi
      i = i+1
c
c   locate each xup(m) in interval (x(i),x(i+1))
c
      do 80 m = j,nup
 50     if(xup(m) .lt. x(i+1)  .or.  i .eq. nm1) go to 60
c
c   augment integral between abscissas to include interval
c   (x(i),x(i+1)) and advance i to i+1
c
        hi = x(i+1)-x(i)
        hi2 = hi*hi
        hi3 = hi2*hi
        sum0 = sum0 + y(i)*hi
        sum1 = sum1 + yp(i)*hi2
        sum2 = sum2 + ypp(i)*hi3
        sum3 = sum3 + (ypp(i+1)-ypp(i))*hi3
        i = i+1
        go to 50
c
c   integral between x(i) and xup(m) is zero
c
 60     if(xup(m) .ne. x(i)) go to 70
        sum = ((sum3/24.D0 + sum2/6.D0) + sum1/2.D0) + sum0
        go to 80
c
c   compute integral between x(i) and xup(m) and evaluate
c   taylor polynomial in reverse order
c
 70     hup = xup(m)-x(i)
        hup2 = hup*hup
        hup3 = hup2*hup
        hup4 = hup3*hup
        hi = x(i+1)-x(i)
        psum0 = y(i)*hup
        psum1 = yp(i)*hup2
        psum2 = ypp(i)*hup3
        psum3 = (ypp(i+1)-ypp(i))*hup4/hi
        sum = (sum3+psum3)/24.D0 + (sum2+psum2)/6.D0
        sum = sum + (sum1+psum1)/2.D0
        sum = sum + (sum0+psum0)
 80     ans(m) = sum
      return
      end
